# DaHelpers <a name="dahelpers"></a>

These are da helpers to help you out.

A growing collection of miscellaneous general-purpose helper methods for
JavaScript in browsers and on NodeJS.

 + [Installation](#installation)
   - [NodeJS](#nodejs)
   - [volo](#volo)
   - [Browser](#browser)
 + [Usage tips](#usage-tips)
   - [Using methods stand-alone](#using-methods-stand-alone)
   - [Modifying Underscore `#template()` to add DaHelpers](#modifying-underscore-template-to-add-dahelpers)
 + [Variables](#variables)
   - [`#USD`](#usd)
   - [`#EUR`](#eur)
   - [`#YN`](#yn)
   - [`#GBP`](#gbp)
   - [`#DEFAULT_CURRENCY`](#default_currency)
   - [`#FIRST_CHAR`](#first_char)
   - [`#WRAP_WIDTH`](#wrap_width)
   - [`#FORMAT_CHARACTER`](#format_character)
   - [`#PLURAL_RULES`](#plural_rules)
   - [`#HTML_ESCAPE_MAPPINGS`](#html_escape_mappings)
 + [Helper functions](#helper-functions)
   - [`#type(v, type)`](#type-v-type)
   - [`#klass(v, klass)`](#klass-v-klass)
   - [`#objAttrs(o)`](#objattrs-o)
   - [`#tag(name, content, [attrs, silence])`](#tag-name-content-attrs-silence)
   - [`#escape(s)`](#escape-s)
   - [`#plural(singular, plural, [plural2...] count)`](#plural-singular-plural-plural2-count)
   - [`#capitalize(s)`](#capitalize-s)
   - [`#titleCase(s, [lowerFirst])`](#titlecase-s-lowerfirst)
   - [`#format(s, format, [formatChar])`](#format-s-format-formatchar)
   - [`#reverse(s)`](#reverse-s)
   - [`#sgroup(s, n)`](#sgroup-s-n)
   - [`#pad(s, len, [char, tail, sep])`](#pad-s-len-char-tail-sep)
   - [`#thousands(num, [sep, decSep])`](#thousands-num-sep-decsep)
   - [`#si(num, [d, thousands, sep, decSep])`](#si-num-d-thousands-sep-decsep)
   - [`#digits(s)`](#digits-s)
   - [`#prefix(num, prefix, sepLong)`](#prefix-num-prefix-seplong)
   - [`#round(num, [d])`](#round-num-d)
   - [`#currency(num, [currency, dec, sep, decSep, si, suffix])`](#currency-num-currency-dec-sep-decsep-si-suffix)
   - [`#makeCurrency(name, currency, dec, sep, decSep, si, suffix)`](#makecurrency-name-currency-dec-sep-decsep-si-suffix)
   - [`#siCurrency(num, [currency, dec, sep, decSep])`](#sicurrency-num-currency-dec-sep-decsep)
   - [`dollars(num, dec, si)`](#dollars-num-dec-si)
   - [`#euros(num, dec, si)`](#euros-num-dec-si)
   - [`#yen(num, dec, si)`](#yen-num-dec-si)
   - [`#yuan(num, dec, si)`](#yuan-num-dec-si)
   - [`#pounds(num, dec, si)`](#pounds-num-dec-si)
   - [`#wrap(s, [len, sep])`](#wrap-s-len-sep)
   - [`#slug(s)`](#slug-s)
   - [`#props(o, p)`](#props-o-p)
   - [`#propset(o, p, [v])`](#propset-o-p-v)
   - [`#walk(obj, cb)`](#walk-obj-cb)
   - [`#sweep(obj, cb)`](#sweep-obj-cb)
   - [`#extend(obj, mixin, [mixin...])`](#extend-obj-mixin-mixin)
   - [`#clone(obj)`](#clone-obj)
   - [`#rekey(obj, map)`](#rekey-obj-map)
   - [`#toArray(v)`](#toarray-v)
   - [`#empty(v)`](#empty-v)
   - [`#truth(v)`](#truth-v)
   - [Tag aliases](#tag-aliases)
 + [Running tests](#running-tests)
 + [Reporting bugs](#reporting-bugs)


## Installation <a name="installation"></a>

This module is in UMD format. It can be used with an AMD loader such as
RequireJS, on NodeJS, or in browsers using `<script>` tag.

### NodeJS <a name="nodejs"></a>

Install with NPM:

    npm install dahelpers


### volo <a name="volo"></a>

Install with:

    volo add foxbunny/dahelpers


### Browser <a name="browser"></a>

Either `require()` it if using RequireJS, or add a `<script>` tag. When using
with the `<script>` tag, the module will create a `dahelpers` global.

## Usage tips <a name="usage-tips"></a>

Here are some usage tips that can make using DaHelpers easier.

### Using methods stand-alone <a name="using-methods-stand-alone"></a>

All methods can be decoupled from the `dahelpers` module/global and used
stand-alone. For example:

    var type = dahelpers.type;
    var thousands = dahelpers.thousands;
    type('foo');
    thousands(3000);


If you are using CoffeeScript, this can be even easier:

    {type, thousands} = dahelpers;
    type 'foo'
    thousands 3000


### Modifying Underscore `#template()` to add DaHelpers <a name="modifying-underscore-template-to-add-dahelpers"></a>

Here is a pattern for including DaHelpers in uderscore templates.

    var type = dahelpers.type;
    var extend = dahelpers.extend;
    var origTemplate = _.template;
    _.template = function(src, data, settings) {
      if (type(data, 'undefined')) {
        var precompiled = origTemplate(src, data, settings);
        return function(data) {
          return precompiled(extend({d: dahelpers}, data));
        }
      } else {
        return origTemplate(src, extend({d: dahelpers}, data), settings);
      }
    };


This makes DaHelpers available as `d` within the templates. Now you can:

    _.template("Here's <%= d.currency(money) %>", {money: 200})
    // returns "Here's $200.00"


## Variables <a name="variables"></a>

Although some of the properties of this module are all-caps, they are by no
means constants. They are, in fact, variables that configure various aspects of
DaHelpers. You are free to modify them any way you need.

### `#USD` <a name="usd"></a>

Symbol for US currency. Default is '$'.

### `#EUR` <a name="eur"></a>

Symbol for EU currency. Default is '€'.

### `#YN` <a name="yn"></a>

Symbol for Japanese and Chinese currencies. Default is '¥'.

### `#GBP` <a name="gbp"></a>

Symbol for UK currency. Default is '£'.

### `#DEFAULT_CURRENCY` <a name="default_currency"></a>

Default curency used by `#currency()` method. Default is '$'.

### `#FIRST_CHAR` <a name="first_char"></a>

Regular expression for capturing the first character of a word. Default is
`/\b[a-z]/gi`. Please see documentation for the
[`#titleCase()`](#titlecase-s-lowerfirst] for information on how this variable
is used.

### `#WRAP_WIDTH` <a name="wrap_width"></a>

Default text wrap width.

### `#FORMAT_CHARACTER` <a name="format_character"></a>

Character used by default in [`#format()`](#format-s-format-formatchar) method.

### `#PLURAL_RULES` <a name="plural_rules"></a>

Returns the form to use based on number `n`. The form is 0 for singular, and 1
or more for plural forms.

This function is called by the
[`#plural()`](#plural-singular-plural-plural2-count) method to yield the
correct form.

Default function accounts for English and compatible pluralization where
singular is used when n==1, and a single plural form for all other cases.

You can see different rules for different langauges at [Unicode
R](http://www.unicode.org/cldr/charts/supplemental/language_plural_rules.html).

### `#HTML_ESCAPE_MAPPINGS` <a name="html_escape_mappings"></a>

Mapping used to escape HTML.

## Helper functions <a name="helper-functions"></a>

Although all the methods are exported as one object, they are completely
decoupled (they call each other by using the reference to the module object
`h`, instead of `this`), so you can assign individual methods to variables and
pass them around.

### `#type(v, type)` <a name="type-v-type"></a>

Tests if `v` is of type `type`. The valid types are:

 + 'null'
 + 'undefined'
 + 'string'
 + 'number'
 + 'date'
 + 'regexp'
 + 'array'
 + 'function'
 + 'object'


Note that this method can be reliably used as a replacement for `typeOf`
function and differentiates between more object types.

If the `type` argument is not supplied, it will return the type of the value.

Example:

    dahelpers.type([], 'array');
    // returns true
    dahelpers.type([])
    // returns 'array'


### `#klass(v, klass)` <a name="klass-v-klass"></a>

Tests if `v` has constructor of `klass`. If `v` is not an object, it returns
`false`.

If the `klass` argument is missing, returns the constructor.

Example:

    dahelpers.klass({});
    // returns `Object` (function)
    dahelpers.klass([], Array);
    // returns `true`


### `#objAttrs(o)` <a name="objattrs-o"></a>

Converts a JavaScript object `o` into a set of HTML attributes where a key is
the attribute name, and value is the attribute value.

Note that the validity of attribute names are not checked, so it's developer's
job to make sure valid attributes are being generated.

All attribute values are double-quoted and any double quotes inside the
attribute values are escaped.

Example:

    dahelpers.obAttrs({foo: 1, bar: 'foo'});
    // returns 'foo="1" bar="foo"'


### `#tag(name, content, [attrs, silence])` <a name="tag-name-content-attrs-silence"></a>

Wraps optional content into a HTML tag with optional attributes hash.

The `name` represents the name of the HTML tag (and it is not checked for
validity at all. The `attrs` is an object whic is passed to
[`#objAttrs()`](#objattrs-o).

If the `silence` argument is `true`, the whole `tag` is only rendered if
`content` is not null or undefined, and can be coerced into a non-empty string.

Example:

    dahelpers.tag('a', 'click here', {href: '#'});
    // returns '<a href="#">click here</a>'


### `#escape(s)` <a name="escape-s"></a>

Escapes special characters in string `s` as a measure for preventing XSS
attacks.

Exampple:

    dahelpers.escape('<a href="#">not so malicious HTML</a>')
    // returns:
    // '&lt;a href=&quot;#&quot;&gt;not so malicious HTML&lt;&#x2F;a&gt;'


### `#plural(singular, plural, [plural2...] count)` <a name="plural-singular-plural-plural2-count"></a>

Provides support for pluralization. All but the last argument are plural forms,
starting with singular, which is the first argument, followed by 0 or more
plural forms.

The function will return an empty string if at least one form of singular and
one form of plural are not passed along with the count.

The pluralization rules are actually defined in the
[`PLURAL_RULES`](#plural_rules) property, which is a function that returns 0
for singular, and 1 or more for plural forms. The correct form is then selected
from the arguments passed to this function.

Example:

    dahelpers.plural('bear', 'bears', 3);  // returns 'bears'


### `#capitalize(s)` <a name="capitalize-s"></a>

Capitalizes the first character of the string `s`. You can used this to build
sentence case.

Example:

    dahelpers.capitalize('foo bar fam');  // returns 'Foo bar fam'


### `#titleCase(s, [lowerFirst])` <a name="titlecase-s-lowerfirst"></a>

Converts the string `s` to Title Case.

This method uses a simple algorhythm for title-casing, so do not expect
exceptions (e.g., it cannot do fancy title cases such as 'Question of Time').

You can change the [`FIRST_CHAR`](#first_char) variable to customize the
regular expression used to find the first character if you need a more complex
behavior.

To understand how the customization works here is a short description of what
`#titleCase()` does with the regexp internally.  The regexp is used in a
`String.prototype.replace()` call as the first argument, and the callback
function is passed the entire match. The match (not any captured group) is then
capitalized using [`#capitalize()`](#capitalize-s).

Because of the way this method works, you generally must include the 'g' flag
in your regexp. The rest is up to you. There is a very crude example of a
customized title case which only capitalizes words that are longer than 4 and
contain only letters.

If the `lowerFirst` is `ture`, the whole string will be lower-cased before
applying the title case. Default is `false`.

Examples:

    dahelpers.titleCase('This is a title');
    // returns 'This Is A Title'


    dahelpers.FIRST_CHAR = /\b[a-z]{4,}/gi;
    dahelpers.titleCase('This is the title');
    // returns 'This is the Title'


### `#format(s, format, [formatChar])` <a name="format-s-format-formatchar"></a>

Formats a string according to the `format`. The format is simply a series of
hash character '#' that map the string's characters to appropriate places one
by one.

This works best with source strings were internal structure has no semantic
like unformatted phone numbers or serial numbers. It doesn't work well for
strings that already have structure or whose length is variable.

The character used in the `format` string can be customed either by passing an
alternative as `formatChar` argument, or by modifying the
[`FORMAT_CHARACTER`](#format_character) variable.

Examples:

    dahelpers.format('abcdef', '##-##-##');  // returns 'ab-cd-ef'
    dahelpers.format('John Doe', '## ###');  // returns 'Jo hnD'
    dahelpers.format('1234', '$$$-$', '$');  // returns '123-4'


### `#reverse(s)` <a name="reverse-s"></a>

Reverses a string.

Example:

    dahelpers.reverse('esrever');  // returns 'reverse'


### `#sgroup(s, n)` <a name="sgroup-s-n"></a>

Groups the string's characters into groups of `n` characters and returns the
groups as an array.

The last group can be shorter than `n` if there are not enough characters.

An empty string is returned if `s` is not defined or is an empty string, and an
array containing the orginal string if `n` is not specified or is 0.

Examples:

    dahelpers.sgroup('Groupings', 3);  // returns ['Gro', 'upi', 'ngs']
    dahelpers.sgroup('Grouping', 3);   // returns ['Gro', 'upi', 'ng']


### `#pad(s, len, [char, tail, sep])` <a name="pad-s-len-char-tail-sep"></a>

Pads a string `s` with `char` characters, so that the output is at least `len`
long.

The `char` is '0' by default.

If `len` is 0 or less than the length of `s`, no padding is done, and the
original string is left intact.

Tail has the same meaning as `len` but from the tail end of the string. The
`sep` character is used to split the string into head and tail, and they are
padded separately and re-merged using the same separator character.

The only case where `tail` behaves differently than `len` is when it is set to
`false`. This has a special meaning internally, where it disables any
processing of the tail if it is `false`.

Examples:

    dahelpers.pad('2', 2);             // returns '02'
    dahelpers.pad('2.5', 0, null, 3);  // returns '2.50'


### `#thousands(num, [sep, decSep])` <a name="thousands-num-sep-decsep"></a>

Adds the thousands separator to `num`.

Default separator is a comma, and can be customized by passing the `sep`
argument.

The `decSep` argument can be used to customize the decimal separator ('.' by
default).

Although the `decSep` can control the output decimal separator, the input
decimal separator is always period. This is a tradeoff to give `#thousands()`
the ability to take JavaScript numbers as input, and still use a different
separator in the output without cluttering the function signature.

Examples:

    dahelpers.thousands(1200000);               // returns '1,200,000'
    dahelpers.thousands(1200000.12, '.', ',');  // returns '1.200.000,00'


### `#si(num, [d, thousands, sep, decSep])` <a name="si-num-d-thousands-sep-decsep"></a>

Converts the number to closes SI factor (Kilo, Mega, etc). Uses only factors of
thousand (k, M, G, T, P, E, and Z) larger than 0.

Due to overlow issues, the Y suffix is not avilable.

The method will only add the next bigger suffix if the number is divisible by
that factor. For example, 1000 can use the 'k' suffix, but 1100 will be
returned as is.

If `d` is specified, it will allow `d` number of decimals after the main unit.
For example, with number 1100, with `d` of 1, the method will add return
'1.1k'. With `d` of 1, 1110 would still be returned as is. Increasing `d` to 2
would allow the method to output '1.11k'. And so on. `d` can be as large as you
want.

if `thousands` is `true`, the thousands separator will be added.

You can control the characters used for separator and decimal separator by
using the `sep` and `decSep` arguments. They work the same way as the
`thousands`.

Examples:

    dahelpers.si(1000);                 // returns '1k'
    dahelpers.si(1200);                 // returns '1200'
    dahelpers.si(1200, 1);              // returns '1.2k'
    dahelpers.si(1200, null, true);     // returns '1,200'


### `#digits(s)` <a name="digits-s"></a>

Removes all non-digit characters from a string. This includes decimal points,
minus sign, and anyting else that does not match the `\d` regular expression.

Examples:

    dahelpers.digits('123.456.7890');           // returns '1234567890'
    dahelpers.digits('Number of items is 12');  // returns '12'


### `#prefix(num, prefix, sepLong)` <a name="prefix-num-prefix-seplong"></a>

Adds a prefix to a number. The `prefix` argument can be any string of any
length. `num` can be a real number, or just any string.

The main difference between `#prefix()` and simple string concatenation is the
handling of the leading minus sign. If there is a minus sign at the beginning
of the number, the prefix will be inserted between the minus sign and the rest
of the number.

The `sepLong` argument is used to separate long prefixes from the number.

Examples:

    dahlperss.prefix(12, '$');          // returns '$12'
    dahelpers.prefix(-12, '$');         // returns '-$12'
    dahelpers.prefix(12, 'foo');        // returns 'foo12'
    dahelpers.prefix(12, 'foo', true);  // returns 'foo 12'


### `#round(num, [d])` <a name="round-num-d"></a>

Round the number to `d` decimal places. `d` is 0 by default.

Examples:

    dahelpers.round(12.34);     // returns 12
    dahelpers.round(12.34, 1);  // returns 12.3


### `#currency(num, [currency, dec, sep, decSep, si, suffix])` <a name="currency-num-currency-dec-sep-decsep-si-suffix"></a>

Formats `num` as currency  with thousands separator or SI suffix. Default
currency is '$', and thousands separators are used by default.

The `dec` argument specifies the number of decimal places (default is 2). This
number is also used when converting to SI suffix.

The `sep` argument specifies the thousands separator (default is ',').

The `decSep` argument specifies the decimal separator (default is '.').

The `si` argument should be a boolean and tells the method to render the number
with SI prefix instead of with thousands separator. Default is `false`.

The `suffix` argument is used to suffix the currency instead of prefixing it.

Example:

    dahelpers.currency(12);            // returns '$12.00'
    dahelpers.currency(12, null, 0);   // returns '$12'
    dahelpers.currency(12, 'Fr');      // returns 'Fr 12.00'
    dahelpers.currency(12, 'USD');     // returns 'USD 12.00'


### `#makeCurrency(name, currency, dec, sep, decSep, si, suffix)` <a name="makecurrency-name-currency-dec-sep-decsep-si-suffix"></a>

Because the `#currency()` method takes many arguments and you might not always
use them all, this method will help you create a somewhat permanent alias for
the mix of arguments you wish to use often.

Except for the `name` argument, the others are passed through to
[`#currency()`](#currency-num-currency-dec-sep-decsep-si-suffix) method, and
work the same way. The `name` is the name you wish to use to refer to the
currency. You can basically use any name you want, but since the name is used
to create a new key on JavaScript object, you should use a name that can be
used effectively in that context.

The method returns a function which takes only the `num` argument and uess
previously specified arguments to return formatted currency. The function is
also accessible through `dahelpers._NAME` key where `NAME` is the name you
originally specified.

To modify the definition of an existing currency, simply call this method again
and use the same name. To remove a currency, you should simply `delete` the
property from the `dahelpers` module (see examples below).

Examples:

    dahelpers.makeCurrency('din', 'Din', 2, '.', ',', false, true);
    dahelpers._din(15000);  // returns '15.000,00 Din'
    delete dahelpers._din;  // removes 'din' currency


### `#siCurrency(num, [currency, dec, sep, decSep])` <a name="sicurrency-num-currency-dec-sep-decsep"></a>

This is a shortcut for
[`#currency()`](#currency-num-currency-dec-sep-decsep-si-suffix) which passes
the si argument.

Example:

    dahelpers.siCurrency(1200, 'Fr');  // returns 'Fr 1.2k'


### `dollars(num, dec, si)` <a name="dollars-num-dec-si"></a>

Shortcut method for formatting US currency.

Example:

    dahelpers.dollars(100);  // returns '$100.00'


### `#euros(num, dec, si)` <a name="euros-num-dec-si"></a>

Shortcut method for formatting EU currency.

Example:

    dahelpers.euros(100);  // returns '€100.00'


### `#yen(num, dec, si)` <a name="yen-num-dec-si"></a>

Shortcut method for formatting Japanese currency.

Example:

    dahelpers.yen(100);  // returns '¥100.00'


### `#yuan(num, dec, si)` <a name="yuan-num-dec-si"></a>

Shortcut method for formatting Chinese currency. Since both Chinese and
Japanese currencies use the same symbol, this method is a simple alias for
[`#yen()`](#yen-num-dec-si).

Example:

    dahelpers.yuan(100);  // returns '¥100.00'


### `#pounds(num, dec, si)` <a name="pounds-num-dec-si"></a>

Shortcut method for formatting UK currency.

Example:

    dahelpers.pounds(100); // returns '£100.00'


### `#wrap(s, [len, sep])` <a name="wrap-s-len-sep"></a>

Wraps the text to make lines of `len` length separated by `sep` separator. The
`len` is 79 by default, and separator is a LF character ('\n').

Default wrap width can be customized globally by changing the
[`WRAP_WIDTH`](#wrap_width) variable.

Code for this method is based on the idea from [James Padolsey's blog
post](http://james.padolsey.com/javascript/wordwrap-for-javascript/).

Example:

    dahelpers.wrap('The quick brown fox jumps over lazy old fox.', 20);
    // returns:
    // 'The quick brown\n
    // fox jumps over\n
    // lazy old fox.'


### `#slug(s)` <a name="slug-s"></a>

Converts a string to a slug (URL-compatible string). This method is fairly
basic, so don't depend on it for strings that contain non-ASCII letters.

Example:

    dahelpers.slug('This is some text.');
    // returns 'this-is-some-text'


### `#props(o, p)` <a name="props-o-p"></a>

Get a value of a property tree `p` on the object `o` or undefined if any of the
segments is undefined without throwing an exception.

Example:

    var obj = {foo: {bar: {baz: 1}}};
    dahelpers.props(obj, 'foo.bar.baz'); // returns 1
    dahelpers.props(obj, 'foo.foo.baz'); // returns undefined


### `#propset(o, p, [v])` <a name="propset-o-p-v"></a>

Sets the value of the property tree `p`'s last leaf to `v` creating all
intermediate segments as necessary.

Example:

    var obj = {}
    dahelpers.propset(obj, 'a.b.c.d.e.f', 1);
    // obj is now {a: {b: {c: {d: {e: {f: 1}}}}}}


### `#walk(obj, cb)` <a name="walk-obj-cb"></a>

Recursively walks down `obj`'s properties and invokes the callback on each one.

The callback function takes two arguments. The first argument is the property
currently being iterated, and the second argument is the name of the key. The
key name will be a full property path. For example a key name for
`obj.foo.bar.baz` would be 'foo.bar.baz' (see example).

The undocumented `key` argument is an internal implementation detail, and
should not be be passed under normal circumstances.

Example:

    var obj = {a: 1, b: 2, c: {a: 1, b: 2}};
    dahelpers.walk(obj, console.log);
    // Logs:
    // 1 a
    // 2 b
    // Object { a=1, b=2 } c
    // 1 c.a
    // 2 c.b


### `#sweep(obj, cb)` <a name="sweep-obj-cb"></a>

Sweeps over the object attributes, and calls the callback on each key. The
return value of the callback is used to build a new object with the same
property structure as the old one.

This method is similar to `#walk()` and uses walk to iterate over the object.

The callback function takes four arguments:

 + the value of the key
 + the full key (e.g, 'foo.bar.baz' for `obj.foo.bar.baz`)
 + boolean flag which is `true` if value is an object


The reason for the latter is that the value's properties will also be iterated
when a value is an object, so you may want to adjust the handling of that case.

If the callback function returns undefined, the matching property will not be
set at all on the resulting object.

Example:

    obj = {a: 1, b: 2, c: 3}
    dahelpers.sweep(obj, function(v) { return v + 1; });
    // Returns {a: 2, b: 3, c: 4}


### `#extend(obj, mixin, [mixin...])` <a name="extend-obj-mixin-mixin"></a>

Deep-copies properties from `mixin`s into `obj`. Any properties that are
already present in `obj` will be overwritten by properties in mixins.

It currently does not clone items within arrays embedded in objects. It just
crates a new array containing the same objects as the original one.

Example:

    obj = {foo: 1, bar: {baz: new Date(2013, 8, 1)}};
    obj1 = {foo: 2, baz: 3};
    dahelpers.extend(obj, obj1)
    // `obj` should now be:
    // {foo: 2, bar: {baz: Date(2013, 8, 1)}, baz: 3}


### `#clone(obj)` <a name="clone-obj"></a>

Returns an exact clone of `obj`.

It currently does not clone items within arrays embedded in objects. It just
crates a new array containing the same objects as the original one.

Example:

    obj = {foo: 1, bar: {baz: new Date(2013, 8, 1)}};
    obj1 = dahelpers.clone(obj)
    obj1.bar.baz.setFullYear(2020);
    obj.bar.baz.getFullYear() == obj1.bar.baz.getFullYear()
    // Should be `false`


### `#rekey(obj, map)` <a name="rekey-obj-map"></a>

Creates a new object whose keys are translated to new names using `map`.

`map` should be a simple object that maps original keys to new keys. Both
original and new keys can be full property subtrees.

The target structure is unrelated to source structure, so an object of
arbitrary complexity (or simplicity) can be created from any object.

Any keys that are not found in the map will not be present in the new object.
Keys that are undefined in the original object will also not be present in the
new object.

Example:

    var obj = {
      a: {
        b: 1,
        c: 2
      },
      d: {
        e: 3,
        f: 4
      }
    };


    dahelpers.rekey(obj, {
      'a.b', 'aa.b.bb',
      'a.c', 'aa.b.cc',
      'a.d', 'aa.b.dd'
    })
    // Returns
    // {aa: b: {{bb: 1, cc: 1}}}


### `#toArray(v)` <a name="toarray-v"></a>

Converts `v` to an array if it's not an array.

Example:

    a = 'foo'
    dahelpers.toArray(a);
    // returns ['foo']


### `#empty(v)` <a name="empty-v"></a>

Tests if `v` is an empty object, array, or string.

Always returns undefined if `v` is not array, object, nor string.

Examples:

    dahelpers.empty({});         // true
    dahelpers.empty([]);         // true
    dahelpers.empty(1);          // undefined
    dahelpers.empty([1,2,3]);    // false
    dahelpers.empty('');         // true
    dahelpers.empty('foo bar');  // false


### `#truth(v)` <a name="truth-v"></a>

A more pragmatic truthy and falsy.

This method returns `false` for the following values:

 + `undefined`
 + `null`
 + `0`
 + `''`
 + `false`
 + `{}`
 + `[]`


For all other values, it will return `true`.

### Tag aliases <a name="tag-aliases"></a>

For convenience we include a few aliases for HTML tags that will call `#tag()`
method with a specific HTML tag name. The tags that are aliased are:

 + a
 + p
 + strong
 + em
 + ul
 + ol
 + li
 + div
 + span


They take the same arguments as the `#tag()` method except `name`.

## Running tests <a name="running-tests"></a>

To run the tests you first need to install all development dependencies. In the
source directory run:

    npm install


Next run:

    node node_modules/mocha/bin/_mocha tests/*.js


To run tests in your browser, simply open `index.html` located in `tests`
directory.

## Reporting bugs <a name="reporting-bugs"></a>

Please report all bugs to the [GitHub issue
tracker](https://github.com/foxbunny/dahelpers/issues). Please check if there
are any failing tests and include that information in the report.
