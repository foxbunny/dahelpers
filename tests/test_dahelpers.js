// Generated by CoffeeScript 1.6.3
var assert, chai, dahelpers, h;

if (typeof require !== "undefined" && require !== null) {
  dahelpers = require('../dahelpers');
  chai = require('chai');
}

assert = chai.assert;

h = dahelpers;

describe('#objAttrs()', function() {
  it('converts objects to HTML attributes', function() {
    var s;
    s = h.objAttrs({
      'class': 'active',
      href: 'http://www.example.com/'
    });
    return assert.equal(s, 'class="active" href="http://www.example.com/"');
  });
  it('returns empty string if object is empty', function() {
    var s;
    s = h.objAttrs({});
    return assert.equal(s, '');
  });
  return it('returns empty string if there are no arguments', function() {
    var s;
    s = h.objAttrs();
    return assert.equal(s, '');
  });
});

describe('#tag()', function() {
  it('returns HTML for a tag', function() {
    var s;
    s = h.tag('a');
    return assert.equal(s, '<a></a>');
  });
  it('returns a tag with content if we specify it', function() {
    var s;
    s = h.tag('a', 'click here');
    return assert.equal(s, '<a>click here</a>');
  });
  it('returns a tag with attributes if specified', function() {
    var s;
    s = h.tag('a', null, {
      href: 'http://example.com/'
    });
    return assert.equal(s, '<a href="http://example.com/"></a>');
  });
  it('will suppress output if `silent` argument is passed', function() {
    var s;
    s = h.tag('a', null, {
      href: 'http://example.com/'
    }, true);
    return assert.equal(s, '');
  });
  return it('will return empty string if no arguments', function() {
    var s;
    s = h.tag();
    return assert.equal(s, '');
  });
});

describe('#plural()', function() {
  it('will return plural with number greater than 1', function() {
    var s;
    s = h.plural('foo', 2);
    return assert.equal(s, 'foos');
  });
  it('will return a singular when count 1', function() {
    var s;
    s = h.plural('foo', 1);
    return assert.equal(s, 'foo');
  });
  it('will return different plural if specified', function() {
    var s;
    s = h.plural('foo', 'bar', 2);
    return assert.equal(s, 'bar');
  });
  it('will not return the plural form if count is 1', function() {
    var s;
    s = h.plural('foo', 'bar', 1);
    return assert.equal(s, 'foo');
  });
  return it('will return an empty string if there are no arguments', function() {
    var s;
    s = h.plural();
    return assert.equal(s, '');
  });
});

describe('#capitalize()', function() {
  it('will capitalize the first letter', function() {
    var s;
    s = h.capitalize('foo');
    return assert.equal(s, 'Foo');
  });
  it('will do nothing when text is all caps', function() {
    var s;
    s = h.capitalize('FOO');
    return assert.equal(s, 'FOO');
  });
  return it('will return an empty string if no arguments are passed', function() {
    var s;
    s = h.capitalize();
    return assert.equal(s, '');
  });
});

describe('#titleCase()', function() {
  it('will Title Case a string', function() {
    var s;
    s = h.titleCase('foo bar');
    return assert.equal(s, 'Foo Bar');
  });
  it('will do nothing if all-caps', function() {
    var s;
    s = h.titleCase('FOO BAR');
    return assert.equal(s, 'FOO BAR');
  });
  it('will capitalize words even if mixed case', function() {
    var s;
    s = h.titleCase('fOO bAR');
    return assert.equal(s, 'FOO BAR');
  });
  return it('will return an empty string if no arguments are passed', function() {
    var s;
    s = h.titleCase();
    return assert.equal(s, '');
  });
});

describe('#format()', function() {
  it('will reformat a string or number using format string', function() {
    var s;
    s = h.format(123456, '## ## ##');
    return assert.equal(s, '12 34 56');
  });
  it("will retain pound characters if source hasn't enough characters", function() {
    var s;
    s = h.format(12, '###');
    return assert.equal(s, '12#');
  });
  it('will omit characters if not enough pound characters', function() {
    var s;
    s = h.format(123, '##');
    return assert.equal(s, '12');
  });
  it('will return original value if no format is specified', function() {
    var s;
    s = h.format(123);
    return assert.equal(s, '123');
  });
  return it('will output an empty string if there are no arguments', function() {
    var s;
    s = h.format();
    return assert.equal(s, '');
  });
});

describe('#reverse()', function() {
  it('will reverse a string', function() {
    var s;
    s = h.reverse('esrever');
    return assert.equal(s, 'reverse');
  });
  return it('will return an empty string if no arguments', function() {
    var s;
    s = h.reverse();
    return assert.equal(s, '');
  });
});

describe('#sgroup()', function() {
  it('will group characters into strings of given length', function() {
    var a;
    a = h.sgroup('123456', 2);
    return assert.deepEqual(a, ['12', '34', '56']);
  });
  it('will return a partial last group if not enough characters', function() {
    var a;
    a = h.sgroup('12345', 2);
    return assert.deepEqual(a, ['12', '34', '5']);
  });
  it('will return the original string as one group if no length', function() {
    var a;
    a = h.sgroup('12345');
    return assert.deepEqual(a, ['12345']);
  });
  it('will return original string as one group if too short', function() {
    var a;
    a = h.sgroup('1', 2);
    return assert.deepEqual(a, ['1']);
  });
  return it('will return empty array given no arguments', function() {
    var a;
    a = h.sgroup();
    return assert.deepEqual(a, []);
  });
});

describe('#pad()', function() {
  it('should pad a number with leading characters', function() {
    var s;
    s = h.pad(123, 4);
    return assert.equal(s, '0123');
  });
  it('should not pad if length is 0', function() {
    var s;
    s = h.pad(123, 0);
    return assert.equal(s, '123');
  });
  it('should pad a number with different character if told to', function() {
    var s;
    s = h.pad(123, 5, '%');
    return assert.equal(s, '%%123');
  });
  it('should pad the tail if tail is specified', function() {
    var s;
    s = h.pad(123.12, 5, null, 4);
    return assert.equal(s, '00123.1200');
  });
  it('should use a different separator for tail if specified', function() {
    var s;
    s = h.pad('123,12', 5, null, 4, ',');
    return assert.equal(s, '00123,1200');
  });
  it('should pad the tail even if head length is 0', function() {
    var s;
    s = h.pad(123.12, 0, null, 4);
    return assert.equal(s, '123.1200');
  });
  return it('should be able to pad anything really', function() {
    var s;
    s = h.pad('foo-bar', 6, '!', 6, '-');
    return assert.equal(s, '!!!foo-bar!!!');
  });
});

describe('#round()', function() {
  it('should round numbers', function() {
    var n;
    n = h.round(1.2345, 3);
    return assert.equal(n, 1.235);
  });
  it('should round to 0 digits by default', function() {
    var n;
    n = h.round(1.2345);
    return assert.equal(n, 1);
  });
  it('should parse numbers from strings', function() {
    var n;
    n = h.round('1.234', 2);
    return assert.equal(n, 1.23);
  });
  return it('should return 0 if input is not numeric', function() {
    var n;
    n = h.round('foo');
    return assert.equal(n, 0);
  });
});

describe('#thousands()', function() {
  it('will add thousands separator to a number', function() {
    var s;
    s = h.thousands(1000);
    return assert.equal(s, '1,000');
  });
  it('should handle situation where first digit is on thousand boundary', function() {
    var s;
    s = h.thousands(100000);
    return assert.equal(s, '100,000');
  });
  it('should work with many zeros', function() {
    var s;
    s = h.thousands(100000000000);
    return assert.equal(s, '100,000,000,000');
  });
  it('should handle floats', function() {
    var s;
    s = h.thousands(100000.12);
    return assert.equal(s, '100,000.12');
  });
  it('should handle floats with many digits', function() {
    var s;
    s = h.thousands(100000.123456);
    return assert.equal(s, '100,000.123456');
  });
  it('strips non-digit charracters', function() {
    var s;
    s = h.thousands('A hundred thousands is 100000');
    return assert.equal(s, '100,000');
  });
  it('will use a different separator if one is given', function() {
    var s;
    s = h.thousands(1000, "'");
    return assert.equal(s, "1'000");
  });
  it('will use a different decimal separator if one is given', function() {
    var s;
    s = h.thousands(1000.123, '.', ',');
    return assert.equal(s, '1.000,123');
  });
  return it('should play nice with negative numbers', function() {
    var s;
    s = h.thousands(-12000);
    return assert.equal(s, '-12,000');
  });
});

describe('#si()', function() {
  it('will suffix k for thousands', function() {
    var s;
    s = h.si(1000);
    return assert.equal(s, '1k');
  });
  it('will suffix M for millions', function() {
    var s;
    s = h.si(1000000);
    return assert.equal(s, '1M');
  });
  it('will suffix G for billions', function() {
    var s;
    s = h.si(1000000000);
    return assert.equal(s, '1G');
  });
  it('will suffix T for trillions', function() {
    var s;
    s = h.si(1000000000000);
    return assert.equal(s, '1T');
  });
  it('will suffix P for quadrillions', function() {
    var s;
    s = h.si(1000000000000000);
    return assert.equal(s, '1P');
  });
  it('will suffix E for quintillions', function() {
    var s;
    s = h.si(1000000000000000000);
    return assert.equal(s, '1E');
  });
  it('will suffix Z for sextillions', function() {
    var s;
    s = h.si(1000000000000000000000);
    return assert.equal(s, '1Z');
  });
  it('will degrade to lower thousand if not a whole thousand', function() {
    var s;
    s = h.si(1100);
    assert.equal(s, '1100');
    s = h.si(1100000);
    assert.equal(s, '1100k');
    s = h.si(1100000000);
    return assert.equal(s, '1100M');
  });
  it('will provide a float if number of decimal places are specified', function() {
    var s;
    s = h.si(1100, 1);
    return assert.equal(s, '1.1k');
  });
  it('will still go down a thousand if not enough decimal places', function() {
    var s;
    s = h.si(1110, 1);
    assert.equal(s, '1110');
    s = h.si(1110, 2);
    return assert.equal(s, '1.11k');
  });
  it('supports unlimited decimal places', function() {
    var s;
    s = h.si(1234560000);
    assert.equal(s, '1234560k');
    s = h.si(1234560000, 5);
    return assert.equal(s, '1.23456G');
  });
  it('should play nice with negative numbers', function() {
    var s;
    s = h.si(-1200000, 1);
    return assert.equal(s, '-1.2M');
  });
  it('should add thousands separators if told to', function() {
    var s;
    s = h.si(12401000, 1, true);
    return assert.equal(s, '12,401k');
  });
  it('should use a thousands separator specified', function() {
    var s;
    s = h.si(12401000, 1, true, "'");
    return assert.equal(s, "12'401k");
  });
  it('should use a different decimal separator if told to', function() {
    var s;
    s = h.si(12401200, 1, true, '.', ',');
    return assert.equal(s, '12.401,2k');
  });
  return it('will return an empty string if provided no arguments', function() {
    var s;
    s = h.si();
    return assert.equal(s, '');
  });
});

describe('#digits()', function() {
  it('will return only the digits from a string', function() {
    var s;
    s = h.digits('a1b2c3d4 5-6#7');
    return assert.equal(s, '1234567');
  });
  return it('will return an empty string if given no arguments', function() {
    var s;
    s = h.digits();
    return assert.equal(s, '');
  });
});

describe('#prefix()', function() {
  it('should add specified prefix to a number', function() {
    return assert.equal(h.prefix(12, '$'), '$12');
  });
  it('should add minus in front of prefix if number is negative', function() {
    return assert.equal(h.prefix(-12, '$'), '-$12');
  });
  return it('should not care if number is a number or not', function() {
    assert.equal(h.prefix('abc', '$'), '$abc');
    return assert.equal(h.prefix('-abc', '$'), '-$abc');
  });
});

describe('#currency()', function() {
  it('should work fine with defaults', function() {
    var s;
    s = h.currency(12);
    return assert.equal(s, '$12.00');
  });
  it('should add thousands separators', function() {
    var s;
    s = h.currency(1200);
    return assert.equal(s, '$1,200.00');
  });
  it('should use any currency we tell it to', function() {
    var s;
    s = h.currency(1200, 'USD');
    return assert.equal(s, 'USD1,200.00');
  });
  it('should round to number of decimals', function() {
    var s;
    s = h.currency(1200.55, null, 1);
    return assert.equal(s, '$1,200.6');
  });
  it('should play nice with negative numbers', function() {
    var s;
    s = h.currency(-1200);
    return assert.equal(s, '-$1,200.00');
  });
  it('should use different separators if told to', function() {
    var s;
    s = h.currency(1200, null, null, "'", ';');
    return assert.equal(s, "$1'200;00");
  });
  it('should use SI suffixes if told to', function() {
    var s;
    s = h.currency(1200, null, null, null, null, true);
    return assert.equal(s, "$1.2k");
  });
  it('should play nice with string input', function() {
    var s;
    s = h.currency('1200');
    return assert.equal(s, '$1,200.00');
  });
  return it('should return 0 if no input', function() {
    var s;
    s = h.currency();
    return assert.equal(s, '$0.00');
  });
});

describe('tag aliases', function() {
  it('will render appropriate tags', function() {
    var tag, tags, _i, _len, _results;
    tags = 'a p strong em ul ol li div span'.split(' ');
    _results = [];
    for (_i = 0, _len = tags.length; _i < _len; _i++) {
      tag = tags[_i];
      _results.push(assert.equal(h[tag](), "<" + tag + "></" + tag + ">"));
    }
    return _results;
  });
  return it('accepts the same arguments as #tag()', function() {
    var tag, tags, _i, _len, _results;
    tags = 'a p strong em ul ol li div span'.split(' ');
    _results = [];
    for (_i = 0, _len = tags.length; _i < _len; _i++) {
      tag = tags[_i];
      _results.push(assert.equal(h[tag]('foo', {
        foo: 'bar'
      }), "<" + tag + " foo=\"bar\">foo</" + tag + ">"));
    }
    return _results;
  });
});
