// Generated by CoffeeScript 1.6.3
var assert, chai, dahelpers, h;

if (typeof require !== "undefined" && require !== null) {
  dahelpers = require('../dahelpers');
  chai = require('chai');
}

assert = chai.assert;

h = dahelpers;

describe('#objAttrs()', function() {
  it('converts objects to HTML attributes', function() {
    var s;
    s = h.objAttrs({
      'class': 'active',
      href: 'http://www.example.com/'
    });
    return assert.equal(s, 'class="active" href="http://www.example.com/"');
  });
  it('returns empty string if object is empty', function() {
    var s;
    s = h.objAttrs({});
    return assert.equal(s, '');
  });
  return it('returns empty string if there are no arguments', function() {
    var s;
    s = h.objAttrs();
    return assert.equal(s, '');
  });
});

describe('#tag()', function() {
  it('returns HTML for a tag', function() {
    var s;
    s = h.tag('a');
    return assert.equal(s, '<a></a>');
  });
  it('returns a tag with content if we specify it', function() {
    var s;
    s = h.tag('a', 'click here');
    return assert.equal(s, '<a>click here</a>');
  });
  it('returns a tag with attributes if specified', function() {
    var s;
    s = h.tag('a', null, {
      href: 'http://example.com/'
    });
    return assert.equal(s, '<a href="http://example.com/"></a>');
  });
  it('will suppress output if `silent` argument is passed', function() {
    var s;
    s = h.tag('a', null, {
      href: 'http://example.com/'
    }, true);
    return assert.equal(s, '');
  });
  return it('will return empty string if no arguments', function() {
    var s;
    s = h.tag();
    return assert.equal(s, '');
  });
});

describe('#plural()', function() {
  it('will return plural with number greater than 1', function() {
    var s;
    s = h.plural('foo', 2);
    return assert.equal(s, 'foos');
  });
  it('will return a singular when count 1', function() {
    var s;
    s = h.plural('foo', 1);
    return assert.equal(s, 'foo');
  });
  it('will return different plural if specified', function() {
    var s;
    s = h.plural('foo', 'bar', 2);
    return assert.equal(s, 'bar');
  });
  it('will not return the plural form if count is 1', function() {
    var s;
    s = h.plural('foo', 'bar', 1);
    return assert.equal(s, 'foo');
  });
  return it('will return an empty string if there are no arguments', function() {
    var s;
    s = h.plural();
    return assert.equal(s, '');
  });
});

describe('#capitalize()', function() {
  it('will capitalize the first letter', function() {
    var s;
    s = h.capitalize('foo');
    return assert.equal(s, 'Foo');
  });
  it('will do nothing when text is all caps', function() {
    var s;
    s = h.capitalize('FOO');
    return assert.equal(s, 'FOO');
  });
  return it('will return an empty string if no arguments are passed', function() {
    var s;
    s = h.capitalize();
    return assert.equal(s, '');
  });
});

describe('#titleCase()', function() {
  it('will Title Case a string', function() {
    var s;
    s = h.titleCase('foo bar');
    return assert.equal(s, 'Foo Bar');
  });
  it('will do nothing if all-caps', function() {
    var s;
    s = h.titleCase('FOO BAR');
    return assert.equal(s, 'FOO BAR');
  });
  it('will capitalize words even if mixed case', function() {
    var s;
    s = h.titleCase('fOO bAR');
    return assert.equal(s, 'FOO BAR');
  });
  return it('will return an empty string if no arguments are passed', function() {
    var s;
    s = h.titleCase();
    return assert.equal(s, '');
  });
});

describe('#format()', function() {
  it('will reformat a string or number using format string', function() {
    var s;
    s = h.format(123456, '## ## ##');
    return assert.equal(s, '12 34 56');
  });
  it("will retain pound characters if source hasn't enough characters", function() {
    var s;
    s = h.format(12, '###');
    return assert.equal(s, '12#');
  });
  it('will omit characters if not enough pound characters', function() {
    var s;
    s = h.format(123, '##');
    return assert.equal(s, '12');
  });
  it('will return original value if no format is specified', function() {
    var s;
    s = h.format(123);
    return assert.equal(s, '123');
  });
  return it('will output an empty string if there are no arguments', function() {
    var s;
    s = h.format();
    return assert.equal(s, '');
  });
});

describe('#reverse()', function() {
  it('will reverse a string', function() {
    var s;
    s = h.reverse('esrever');
    return assert.equal(s, 'reverse');
  });
  return it('will return an empty string if no arguments', function() {
    var s;
    s = h.reverse();
    return assert.equal(s, '');
  });
});

describe('#sgroup()', function() {
  it('will group characters into strings of given length', function() {
    var a;
    a = h.sgroup('123456', 2);
    return assert.deepEqual(a, ['12', '34', '56']);
  });
  it('will return a partial last group if not enough characters', function() {
    var a;
    a = h.sgroup('12345', 2);
    return assert.deepEqual(a, ['12', '34', '5']);
  });
  it('will return the original string as one group if no length', function() {
    var a;
    a = h.sgroup('12345');
    return assert.deepEqual(a, ['12345']);
  });
  it('will return original string as one group if too short', function() {
    var a;
    a = h.sgroup('1', 2);
    return assert.deepEqual(a, ['1']);
  });
  return it('will return empty array given no arguments', function() {
    var a;
    a = h.sgroup();
    return assert.deepEqual(a, []);
  });
});

describe('#thousands()', function() {
  it('will add thousands separator to a number', function() {
    var s;
    s = h.thousands(1000);
    return assert.equal(s, '1,000');
  });
  it('should handle situation where first digit is on thousand boundary', function() {
    var s;
    s = h.thousands(100000);
    return assert.equal(s, '100,000');
  });
  it('should work with many zeros', function() {
    var s;
    s = h.thousands(100000000000);
    return assert.equal(s, '100,000,000,000');
  });
  it('should handle floats', function() {
    var s;
    s = h.thousands(100000.12);
    return assert.equal(s, '100,000.12');
  });
  it('should handle floats with many digits', function() {
    var s;
    s = h.thousands(100000.123456);
    return assert.equal(s, '100,000.123456');
  });
  it('strips non-digit charracters', function() {
    var s;
    s = h.thousands('A hundred thousands is 100000');
    return assert.equal(s, '100,000');
  });
  it('will use a different separator if one is given', function() {
    var s;
    s = h.thousands(1000, "'");
    return assert.equal(s, "1'000");
  });
  return it('will use a different decimal separator if one is given', function() {
    var s;
    s = h.thousands(1000.123, '.', ',');
    return assert.equal(s, '1.000,123');
  });
});

describe('#si()', function() {
  it('will suffix k for thousands', function() {
    var s;
    s = h.si(1000);
    return assert.equal(s, '1k');
  });
  it('will suffix M for millions', function() {
    var s;
    s = h.si(1000000);
    return assert.equal(s, '1M');
  });
  it('will suffix G for billions', function() {
    var s;
    s = h.si(1000000000);
    return assert.equal(s, '1G');
  });
  it('will suffix T for trillions', function() {
    var s;
    s = h.si(1000000000000);
    return assert.equal(s, '1T');
  });
  it('will suffix P for quadrillions', function() {
    var s;
    s = h.si(1000000000000000);
    return assert.equal(s, '1P');
  });
  it('will suffix E for quintillions', function() {
    var s;
    s = h.si(1000000000000000000);
    return assert.equal(s, '1E');
  });
  it('will suffix Z for sextillions', function() {
    var s;
    s = h.si(1000000000000000000000);
    return assert.equal(s, '1Z');
  });
  it('will degrade to lower thousand if not a whole thousand', function() {
    var s;
    s = h.si(1100);
    assert.equal(s, '1100');
    s = h.si(1100000);
    assert.equal(s, '1100k');
    s = h.si(1100000000);
    return assert.equal(s, '1100M');
  });
  it('will provide a float if number of decimal places are specified', function() {
    var s;
    s = h.si(1100, 1);
    return assert.equal(s, '1.1k');
  });
  it('will still go down a thousand if not enough decimal places', function() {
    var s;
    s = h.si(1110, 1);
    assert.equal(s, '1110');
    s = h.si(1110, 2);
    return assert.equal(s, '1.11k');
  });
  it('supports unlimited decimal places', function() {
    var s;
    s = h.si(1234560000);
    assert.equal(s, '1234560k');
    s = h.si(1234560000, 5);
    return assert.equal(s, '1.23456G');
  });
  return it('will return an empty string if provided no arguments', function() {
    var s;
    s = h.si();
    return assert.equal(s, '');
  });
});

describe('#digits()', function() {
  it('will return only the digits from a string', function() {
    var s;
    s = h.digits('a1b2c3d4 5-6#7');
    return assert.equal(s, '1234567');
  });
  return it('will return an empty string if given no arguments', function() {
    var s;
    s = h.digits();
    return assert.equal(s, '');
  });
});

describe('tag aliases', function() {
  it('will render appropriate tags', function() {
    var tag, tags, _i, _len, _results;
    tags = 'a p strong em ul ol li div span'.split(' ');
    _results = [];
    for (_i = 0, _len = tags.length; _i < _len; _i++) {
      tag = tags[_i];
      _results.push(assert.equal(h[tag](), "<" + tag + "></" + tag + ">"));
    }
    return _results;
  });
  return it('accepts the same arguments as #tag()', function() {
    var tag, tags, _i, _len, _results;
    tags = 'a p strong em ul ol li div span'.split(' ');
    _results = [];
    for (_i = 0, _len = tags.length; _i < _len; _i++) {
      tag = tags[_i];
      _results.push(assert.equal(h[tag]('foo', {
        foo: 'bar'
      }), "<" + tag + " foo=\"bar\">foo</" + tag + ">"));
    }
    return _results;
  });
});
